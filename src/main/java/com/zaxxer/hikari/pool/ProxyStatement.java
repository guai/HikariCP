/*
 * Copyright (C) 2013 Brett Wooldridge
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.zaxxer.hikari.pool;

import com.zaxxer.hikari.util.DontRecord;
import com.zaxxer.hikari.util.Marshaller;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayDeque;
import java.util.Iterator;
import java.util.Queue;

/**
 * This is the proxy class for java.sql.Statement.
 *
 * @author Brett Wooldridge
 */
public abstract class ProxyStatement<T extends Statement> implements Statement
{
   private static final Logger LOGGER = LoggerFactory.getLogger(ProxyStatement.class);

   protected final ProxyConnection connection;
   protected final T delegate;

   private boolean isClosed;

   T twinDelegate;
   final ArrayDeque<Record> invocationQueue;
   Record tailRecord;
   ResultSet proxyResultSet;

   ProxyStatement(ProxyConnection connection, T statement)
   {
      this.connection = connection;
      this.delegate = statement;
      this.invocationQueue = new ArrayDeque<>(5);
   }

   @SuppressWarnings("unused")
   final SQLException checkException(SQLException e)
   {
      return connection.checkException(e);
   }

   /** {@inheritDoc} */
   @Override
   public final String toString()
   {
      final String delegateToString = delegate.toString();
      return this.getClass().getSimpleName() + '@' + System.identityHashCode(this) + " wrapping " + delegateToString;
   }

   public char getClassId() {
      return 'S';
   }

   final void checkTwinException(SQLException sqle) throws SQLException {
      if (LOGGER.isTraceEnabled())
         LOGGER.trace(getClass().getName() + ".checkTwinException", sqle);
      if (twinDelegate != null) {
         try {
            twinDelegate.close();
         } catch (SQLException e) {
            LOGGER.error("Failed to close twin connection", e);
         }
         twinDelegate = null;
      }
      connection.checkTwinException(sqle);
   }

   final boolean isFallbackMode() {
      return twinDelegate == null;
   }

   final void drainQueue() {
      if (invocationQueue.isEmpty()) return;
      Queue<Record> connectionQueue = connection.invocationQueue;
      Iterator<Record> iterator = invocationQueue.iterator();
      while (iterator.hasNext()) {
         Record record = iterator.next();
         connectionQueue.add(record);
         iterator.remove();
      }
   }

   private int getConnectionId() {
      return System.identityHashCode(connection);
   }

   private int getStatementId() {
      return System.identityHashCode(this);
   }

   protected final void invoked(String method, Object[] args) {
      invocationQueue.add(tailRecord = new Record(getConnectionId(), getStatementId(), getClassId(), method, args));
      if (LOGGER.isTraceEnabled())
         LOGGER.trace(tailRecord.toString());
   }

   // **********************************************************************
   //                 Overridden java.sql.Statement Methods
   // **********************************************************************

   /** {@inheritDoc} */
   @Override
   public final void close() throws SQLException
   {
      synchronized (this) {
         if (isClosed) {
            return;
         }

         isClosed = true;
      }

      connection.untrackStatement(this);

      try {
         delegate.close();
         if (twinDelegate != null)
            try {
               twinDelegate.close();
            } catch (SQLException e) {
               LOGGER.error("Failed to close twin connection", e);
            }

         if (isFallbackMode()) {
            invoked("close ()V", Marshaller.emptyObjectArray);
            drainQueue();
         }
      }
      catch (SQLException e) {
         throw checkException(e);
      }
   }

   /** {@inheritDoc} */
   @Override
   public Connection getConnection() throws SQLException
   {
      return connection;
   }

   /** {@inheritDoc} */
   @Override
   public boolean execute(String sql) throws SQLException
   {
      connection.markCommitStateDirty();
      boolean result = delegate.execute(sql);

      if (!isFallbackMode())
         try {
            twinDelegate.execute(sql);
         } catch (SQLException e) {
            checkTwinException(e);
         }
      return result;
   }

   /** {@inheritDoc} */
   @Override
   public boolean execute(String sql, int autoGeneratedKeys) throws SQLException
   {
      connection.markCommitStateDirty();
      boolean result = delegate.execute(sql, autoGeneratedKeys);

      if (!isFallbackMode())
         try {
            twinDelegate.execute(sql, autoGeneratedKeys);
         } catch (SQLException e) {
            checkTwinException(e);
         }
      return result;
   }

   /** {@inheritDoc} */
   @Override
   @DontRecord
   public ResultSet executeQuery(String sql) throws SQLException
   {
      connection.markCommitStateDirty();
      ResultSet resultSet = delegate.executeQuery(sql);
      return ProxyFactory.getProxyResultSet(connection, this, resultSet);
   }

   /** {@inheritDoc} */
   @Override
   public int executeUpdate(String sql) throws SQLException
   {
      connection.markCommitStateDirty();
      int result = delegate.executeUpdate(sql);

      if (!isFallbackMode())
         try {
            twinDelegate.executeUpdate(sql);
         } catch (SQLException e) {
            checkTwinException(e);
         }
      return result;
   }

   /** {@inheritDoc} */
   @Override
   public int[] executeBatch() throws SQLException
   {
      connection.markCommitStateDirty();
      int[] result = delegate.executeBatch();
      try {
         if (!isFallbackMode()) twinDelegate.executeBatch();
      } catch (SQLException e) {
         checkTwinException(e);
      }
      return result;
   }

   /** {@inheritDoc} */
   @Override
   public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException
   {
      connection.markCommitStateDirty();
      int result = delegate.executeUpdate(sql, autoGeneratedKeys);

      if (!isFallbackMode())
         try {
            twinDelegate.executeUpdate(sql, autoGeneratedKeys);
         } catch (SQLException e) {
            checkTwinException(e);
         }
      return result;
   }

   /** {@inheritDoc} */
   @Override
   public int executeUpdate(String sql, int[] columnIndexes) throws SQLException
   {
      connection.markCommitStateDirty();
      int result = delegate.executeUpdate(sql, columnIndexes);

      if (!isFallbackMode())
         try {
            twinDelegate.executeUpdate(sql, columnIndexes);
         } catch (SQLException e) {
            checkTwinException(e);
         }
      return result;
   }

   /** {@inheritDoc} */
   @Override
   public int executeUpdate(String sql, String[] columnNames) throws SQLException
   {
      connection.markCommitStateDirty();
      int result = delegate.executeUpdate(sql, columnNames);

      if (!isFallbackMode())
         try {
            twinDelegate.executeUpdate(sql, columnNames);
         } catch (SQLException e) {
            checkTwinException(e);
         }
      return result;
   }

   /** {@inheritDoc} */
   @Override
   public boolean execute(String sql, int[] columnIndexes) throws SQLException
   {
      connection.markCommitStateDirty();
      boolean result = delegate.execute(sql, columnIndexes);

      if (!isFallbackMode())
         try {
            twinDelegate.execute(sql, columnIndexes);
         } catch (SQLException e) {
            checkTwinException(e);
         }
      return result;
   }

   /** {@inheritDoc} */
   @Override
   public boolean execute(String sql, String[] columnNames) throws SQLException
   {
      connection.markCommitStateDirty();
      boolean result = delegate.execute(sql, columnNames);

      if (!isFallbackMode())
         try {
            twinDelegate.execute(sql, columnNames);
         } catch (SQLException e) {
            checkTwinException(e);
         }
      return result;
   }

   /** {@inheritDoc} */
   @Override
   public long[] executeLargeBatch() throws SQLException
   {
      connection.markCommitStateDirty();
      long[] result = delegate.executeLargeBatch();
      try {
         delegate.executeLargeBatch();
      } catch (SQLException e) {
         checkTwinException(e);
      }
      return result;
   }

   /** {@inheritDoc} */
   @Override
   public long executeLargeUpdate(String sql) throws SQLException
   {
      connection.markCommitStateDirty();
      long result = delegate.executeLargeUpdate(sql);

      if (!isFallbackMode())
         try {
            twinDelegate.executeLargeUpdate(sql);
         } catch (SQLException e) {
            checkTwinException(e);
         }
      return result;
   }

   /** {@inheritDoc} */
   @Override
   public long executeLargeUpdate(String sql, int autoGeneratedKeys) throws SQLException
   {
      connection.markCommitStateDirty();
      long result = delegate.executeLargeUpdate(sql, autoGeneratedKeys);

      if (!isFallbackMode())
         try {
            twinDelegate.executeLargeUpdate(sql, autoGeneratedKeys);
         } catch (SQLException e) {
            checkTwinException(e);
         }
      return result;
   }

   /** {@inheritDoc} */
   @Override
   public long executeLargeUpdate(String sql, int[] columnIndexes) throws SQLException
   {
      connection.markCommitStateDirty();
      long result = delegate.executeLargeUpdate(sql, columnIndexes);

      if (!isFallbackMode())
         try {
            twinDelegate.executeLargeUpdate(sql, columnIndexes);
         } catch (SQLException e) {
            checkTwinException(e);
         }
      return result;
   }

   /** {@inheritDoc} */
   @Override
   public long executeLargeUpdate(String sql, String[] columnNames) throws SQLException
   {
      connection.markCommitStateDirty();
      long result = delegate.executeLargeUpdate(sql, columnNames);

      if (!isFallbackMode())
         try {
            twinDelegate.executeLargeUpdate(sql, columnNames);
         } catch (SQLException e) {
            checkTwinException(e);
         }
      return result;
   }

   /** {@inheritDoc} */
   @Override
   public ResultSet getResultSet() throws SQLException {
      final ResultSet resultSet = delegate.getResultSet();
      //todo check if always 'select'
      if (resultSet != null) {
         if (proxyResultSet == null || ((ProxyResultSet) proxyResultSet).delegate != resultSet) {
            proxyResultSet = ProxyFactory.getProxyResultSet(connection, this, resultSet);
         }
      }
      else {
         proxyResultSet = null;
      }
      return proxyResultSet;
   }

   /** {@inheritDoc} */
   @Override
   public ResultSet getGeneratedKeys() throws SQLException
   {
      ResultSet resultSet = delegate.getGeneratedKeys();
      if (proxyResultSet == null || ((ProxyResultSet) proxyResultSet).delegate != resultSet) {
         proxyResultSet = ProxyFactory.getProxyResultSet(connection, this, resultSet);
      }
      return proxyResultSet;
   }

   /** {@inheritDoc} */
   @Override
   @SuppressWarnings("unchecked")
   public final <T> T unwrap(Class<T> iface) throws SQLException
   {
      if (iface.isInstance(delegate)) {
         return (T) delegate;
      }
      else if (delegate != null) {
          return delegate.unwrap(iface);
      }

      throw new SQLException("Wrapped statement is not an instance of " + iface);
   }
}
